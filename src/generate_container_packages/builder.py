"""Debian package building module."""

import shutil
import subprocess
import tempfile
from pathlib import Path

from generate_container_packages.loader import AppDefinition


class BuildError(Exception):
    """Raised when package build fails."""


def build_package(
    app_def: AppDefinition,
    rendered_dir: Path,
    output_dir: Path,
    keep_temp: bool = False,
) -> Path:
    """Build Debian package from application definition and rendered templates.

    Args:
        app_def: Application definition with metadata and files
        rendered_dir: Directory containing rendered template files
        output_dir: Directory to place built artifacts
        keep_temp: If True, preserve build directory after build

    Returns:
        Path to generated .deb file

    Raises:
        BuildError: If package build fails
    """
    # Create temporary build directory
    build_dir = Path(tempfile.mkdtemp(prefix="container-pkg-"))

    try:
        # Get package name and version for directory name
        pkg_name = app_def.metadata["package_name"]
        version = app_def.metadata["version"]
        source_dir = build_dir / f"{pkg_name}-{version}"

        # Prepare build directory
        prepare_build_directory(app_def, rendered_dir, source_dir)

        # Set correct permissions
        set_permissions(source_dir)

        # Build package
        run_dpkg_buildpackage(source_dir)

        # Collect artifacts
        artifacts = collect_artifacts(build_dir, output_dir, pkg_name, version)

        if not artifacts:
            raise BuildError("No .deb file generated by dpkg-buildpackage")

        # Return path to .deb file
        deb_file = next((a for a in artifacts if a.suffix == ".deb"), None)
        if not deb_file:
            raise BuildError("No .deb file found in build artifacts")

        return deb_file

    except BuildError:
        # Re-raise expected build errors without preservation message
        # (cleanup still happens in finally block)
        raise

    except Exception:
        # Preserve build directory on unexpected error if requested
        if keep_temp:
            print(f"Build directory preserved at: {build_dir}")
        raise

    finally:
        # Clean up build directory unless requested to keep
        if not keep_temp and build_dir.exists():
            shutil.rmtree(build_dir)


def prepare_build_directory(
    app_def: AppDefinition, rendered_dir: Path, source_dir: Path
) -> None:
    """Prepare build directory with all required files.

    Args:
        app_def: Application definition
        rendered_dir: Directory with rendered template files
        source_dir: Source directory to prepare
    """
    # Create directory structure
    source_dir.mkdir(parents=True, exist_ok=True)

    # Copy source files from input directory
    copy_source_files(app_def, source_dir)

    # Copy rendered template files from rendered directory
    copy_rendered_files(rendered_dir, source_dir)


def copy_source_files(app_def: AppDefinition, source_dir: Path) -> None:
    """Copy application source files to build directory.

    Args:
        app_def: Application definition with file paths
        source_dir: Destination directory

    Raises:
        BuildError: If required file is missing
    """
    # Get input directory from AppDefinition
    input_dir = app_def.input_dir

    # Copy required files
    required_files = ["metadata.yaml", "docker-compose.yml", "config.yml"]
    for filename in required_files:
        src = input_dir / filename
        if not src.exists():
            raise BuildError(f"Required file missing: {filename}")
        dst = source_dir / filename
        shutil.copy2(src, dst)

    # Copy optional icon
    if app_def.icon_path and app_def.icon_path.exists():
        dst = source_dir / app_def.icon_path.name
        shutil.copy2(app_def.icon_path, dst)

    # Copy optional screenshots
    for screenshot_path in app_def.screenshot_paths:
        if screenshot_path.exists():
            dst = source_dir / screenshot_path.name
            shutil.copy2(screenshot_path, dst)

    # Generate .env.template from default_config
    generate_env_template(app_def, source_dir)


def generate_env_template(app_def: AppDefinition, source_dir: Path) -> None:
    """Generate .env.template file from default configuration.

    Args:
        app_def: Application definition
        source_dir: Destination directory
    """
    default_config = app_def.metadata.get("default_config", {})

    if not default_config:
        # Create empty file if no defaults
        env_template = source_dir / ".env.template"
        env_template.write_text("# No default configuration\n", encoding="utf-8")
        return

    # Generate environment variable file
    lines = ["# Default environment variables\n"]
    for key, value in sorted(default_config.items()):
        # Escape special characters and quote the value for .env files
        value_str = (
            str(value)
            .replace("\\", "\\\\")
            .replace("\n", "\\n")
            .replace("\r", "\\r")
            .replace('"', '\\"')
            .replace("$", "$$")
            .replace("`", "\\`")
        )
        lines.append(f'{key}="{value_str}"\n')

    env_template = source_dir / ".env.template"
    env_template.write_text("".join(lines), encoding="utf-8")


def copy_rendered_files(rendered_dir: Path, source_dir: Path) -> None:
    """Copy rendered template files to build directory.

    Args:
        rendered_dir: Directory containing rendered files
        source_dir: Destination directory
    """
    # Copy the entire debian directory
    debian_src = rendered_dir / "debian"
    debian_dst = source_dir / "debian"

    if debian_src.exists():
        shutil.copytree(debian_src, debian_dst, dirs_exist_ok=True)


def set_permissions(source_dir: Path) -> None:
    """Set correct file permissions for Debian package files.

    Args:
        source_dir: Source directory containing files
    """
    debian_dir = source_dir / "debian"

    # Make debian/rules executable
    rules_file = debian_dir / "rules"
    if rules_file.exists():
        rules_file.chmod(0o755)

    # Make maintainer scripts executable
    maintainer_scripts = ["postinst", "prerm", "postrm", "preinst"]
    for script in maintainer_scripts:
        script_file = debian_dir / script
        if script_file.exists():
            script_file.chmod(0o755)


def run_dpkg_buildpackage(source_dir: Path) -> subprocess.CompletedProcess:
    """Execute dpkg-buildpackage to build package.

    Args:
        source_dir: Source directory to build from

    Returns:
        CompletedProcess result

    Raises:
        BuildError: If build fails
    """
    # Build command: binary only, unsigned
    cmd = ["dpkg-buildpackage", "-b", "-us", "-uc"]

    try:
        result = subprocess.run(
            cmd,
            cwd=source_dir,
            capture_output=True,
            text=True,
            check=False,
        )

        # Check if build was successful
        if result.returncode != 0:
            error_msg = f"dpkg-buildpackage failed with exit code {result.returncode}\n"
            error_msg += f"STDOUT:\n{result.stdout}\n"
            error_msg += f"STDERR:\n{result.stderr}"
            raise BuildError(error_msg)

        return result

    except FileNotFoundError as e:
        raise BuildError(
            "dpkg-buildpackage not found.\nInstall with: sudo apt install dpkg-dev debhelper"
        ) from e


def collect_artifacts(
    build_dir: Path, output_dir: Path, pkg_name: str, version: str
) -> list[Path]:
    """Collect build artifacts and move to output directory.

    Args:
        build_dir: Build directory containing artifacts
        output_dir: Destination directory for artifacts
        pkg_name: Package name
        version: Package version

    Returns:
        List of artifact paths in output directory
    """
    # Ensure output directory exists
    output_dir.mkdir(parents=True, exist_ok=True)

    # Patterns for artifacts in build_dir (not source_dir)
    patterns = [
        f"{pkg_name}_{version}_*.deb",
        f"{pkg_name}_{version}_*.buildinfo",
        f"{pkg_name}_{version}_*.changes",
    ]

    artifacts = []
    for pattern in patterns:
        matches = list(build_dir.glob(pattern))
        for artifact in matches:
            dest = output_dir / artifact.name
            shutil.move(str(artifact), str(dest))
            artifacts.append(dest)

    return artifacts
