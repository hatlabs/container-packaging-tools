"""Debian package building module."""

import shutil
import subprocess
import tempfile
from pathlib import Path
from typing import Any

import yaml

from generate_container_packages.labels import generate_homarr_labels
from generate_container_packages.loader import AppDefinition
from generate_container_packages.middleware import generate_forwardauth_middleware
from generate_container_packages.oidc_snippet import generate_oidc_snippet
from generate_container_packages.prestart import generate_prestart_script
from generate_container_packages.registry import generate_registry_toml
from generate_container_packages.routing import generate_routing_yml
from generate_container_packages.traefik import inject_traefik_labels


class BuildError(Exception):
    """Raised when package build fails."""


def build_package(
    app_def: AppDefinition,
    rendered_dir: Path,
    output_dir: Path,
    keep_temp: bool = False,
) -> Path:
    """Build Debian package from application definition and rendered templates.

    Args:
        app_def: Application definition with metadata and files
        rendered_dir: Directory containing rendered template files
        output_dir: Directory to place built artifacts
        keep_temp: If True, preserve build directory after build

    Returns:
        Path to generated .deb file

    Raises:
        BuildError: If package build fails
    """
    # Create temporary build directory
    build_dir = Path(tempfile.mkdtemp(prefix="container-pkg-"))

    try:
        # Get package name and version for directory name
        pkg_name = app_def.metadata["package_name"]
        version = app_def.metadata["version"]
        source_dir = build_dir / f"{pkg_name}-{version}"

        # Prepare build directory
        prepare_build_directory(app_def, rendered_dir, source_dir)

        # Set correct permissions
        set_permissions(source_dir)

        # Build package
        run_dpkg_buildpackage(source_dir)

        # Collect artifacts
        artifacts = collect_artifacts(build_dir, output_dir, pkg_name, version)

        if not artifacts:
            raise BuildError("No .deb file generated by dpkg-buildpackage")

        # Return path to .deb file
        deb_file = next((a for a in artifacts if a.suffix == ".deb"), None)
        if not deb_file:
            raise BuildError("No .deb file found in build artifacts")

        return deb_file

    except BuildError:
        # Re-raise expected build errors without preservation message
        # (cleanup still happens in finally block)
        raise

    except Exception:
        # Preserve build directory on unexpected error if requested
        if keep_temp:
            print(f"Build directory preserved at: {build_dir}")
        raise

    finally:
        # Clean up build directory unless requested to keep
        if not keep_temp and build_dir.exists():
            shutil.rmtree(build_dir)


def prepare_build_directory(
    app_def: AppDefinition, rendered_dir: Path, source_dir: Path
) -> None:
    """Prepare build directory with all required files.

    Args:
        app_def: Application definition
        rendered_dir: Directory with rendered template files
        source_dir: Source directory to prepare
    """
    # Create directory structure
    source_dir.mkdir(parents=True, exist_ok=True)

    # Copy source files from input directory
    copy_source_files(app_def, source_dir)

    # Copy rendered template files from rendered directory
    copy_rendered_files(rendered_dir, source_dir)


def copy_source_files(app_def: AppDefinition, source_dir: Path) -> None:
    """Copy application source files to build directory.

    Args:
        app_def: Application definition with file paths
        source_dir: Destination directory

    Raises:
        BuildError: If required file is missing
    """
    # Get input directory from AppDefinition
    input_dir = app_def.input_dir

    # Copy required files (except docker-compose which needs label injection)
    required_files = ["metadata.yaml", "config.yml"]
    for filename in required_files:
        src = input_dir / filename
        if not src.exists():
            raise BuildError(f"Required file missing: {filename}")
        dst = source_dir / filename
        shutil.copy2(src, dst)

    # Check docker-compose.yml exists
    compose_src = input_dir / "docker-compose.yml"
    if not compose_src.exists():
        raise BuildError("Required file missing: docker-compose.yml")

    # Inject Homarr labels into docker-compose.yml
    compose_with_labels = inject_homarr_labels(
        app_def.compose, app_def.metadata, app_def.icon_path
    )

    # Inject Traefik labels and network
    compose_with_labels = inject_traefik_labels(
        compose_with_labels, app_def.metadata, app_def.compose
    )

    # Fix boolean restart values that PyYAML parsed from "no"/"yes"
    compose_with_labels = _fix_restart_policy(compose_with_labels)
    compose_dst = source_dir / "docker-compose.yml"
    with open(compose_dst, "w", encoding="utf-8") as f:
        yaml.dump(compose_with_labels, f, default_flow_style=False, sort_keys=False)

    # Copy optional icon
    if app_def.icon_path and app_def.icon_path.exists():
        dst = source_dir / app_def.icon_path.name
        shutil.copy2(app_def.icon_path, dst)

    # Copy optional screenshots
    for screenshot_path in app_def.screenshot_paths:
        if screenshot_path.exists():
            dst = source_dir / screenshot_path.name
            shutil.copy2(screenshot_path, dst)

    # Copy optional assets directory
    if app_def.assets_dir and app_def.assets_dir.exists():
        shutil.copytree(app_def.assets_dir, source_dir / "assets")

    # Generate env.template from default_config
    generate_env_template(app_def, source_dir)

    # Generate prestart.sh script
    generate_prestart_file(app_def, source_dir)

    # Generate app registry file for homarr-container-adapter
    generate_registry_file(app_def, source_dir)

    # Generate OIDC client snippet for Authelia (if OIDC app)
    generate_oidc_snippet_file(app_def, source_dir)

    # Generate per-app ForwardAuth middleware (if custom headers)
    generate_middleware_file(app_def, source_dir)

    # Generate routing.yml for generic proxy routing
    generate_routing_file(app_def, source_dir)


def generate_env_template(app_def: AppDefinition, source_dir: Path) -> None:
    """Generate env.template and env.user-template files from default configuration.

    Args:
        app_def: Application definition
        source_dir: Destination directory

    Generates two files:
    - env.template: Full defaults including system variables (-> env.defaults)
    - env.user-template: App defaults as comments for user reference (-> env)
    """
    package_name = app_def.metadata["package_name"]
    default_config = app_def.metadata.get("default_config", {})

    # Generate env.template (full defaults for env.defaults)
    # Only CONTAINER_DATA_ROOT is system-managed
    # Apps define their own PUID/PGID/TZ in default_config if needed
    lines = [
        "# System-managed variables (do not modify)\n",
        f'CONTAINER_DATA_ROOT="/var/lib/container-apps/{package_name}/data"\n',
        "\n",
    ]

    if default_config:
        lines.append("# Application configuration\n")

    # Build escaped config values (used by both templates)
    escaped_config = {}
    for key, value in sorted(default_config.items()):
        # Escape special characters and quote the value for .env files
        value_str = (
            str(value)
            .replace("\\", "\\\\")
            .replace("\n", "\\n")
            .replace("\r", "\\r")
            .replace('"', '\\"')
            .replace("$", "$$")
            .replace("`", "\\`")
        )
        escaped_config[key] = value_str
        lines.append(f'{key}="{value_str}"\n')

    env_template = source_dir / "env.template"
    env_template.write_text("".join(lines), encoding="utf-8")

    # Generate env.user-template (commented defaults for user env file)
    # No system variables here - apps define their own PUID/PGID/TZ if needed
    user_lines = [
        "# User environment overrides\n",
        "# Uncomment and modify values to override defaults from env.defaults\n",
        "\n",
    ]

    if escaped_config:
        user_lines.append("# Application configuration\n")

    for key, value_str in escaped_config.items():
        user_lines.append(f'#{key}="{value_str}"\n')

    env_user_template = source_dir / "env.user-template"
    env_user_template.write_text("".join(user_lines), encoding="utf-8")


def copy_rendered_files(rendered_dir: Path, source_dir: Path) -> None:
    """Copy rendered template files to build directory.

    Args:
        rendered_dir: Directory containing rendered files
        source_dir: Destination directory
    """
    # Copy the entire debian directory
    debian_src = rendered_dir / "debian"
    debian_dst = source_dir / "debian"

    if debian_src.exists():
        shutil.copytree(debian_src, debian_dst, dirs_exist_ok=True)


def set_permissions(source_dir: Path) -> None:
    """Set correct file permissions for Debian package files.

    Args:
        source_dir: Source directory containing files
    """
    debian_dir = source_dir / "debian"

    # Make debian/rules executable
    rules_file = debian_dir / "rules"
    if rules_file.exists():
        rules_file.chmod(0o755)

    # Make maintainer scripts executable
    maintainer_scripts = ["postinst", "prerm", "postrm", "preinst"]
    for script in maintainer_scripts:
        script_file = debian_dir / script
        if script_file.exists():
            script_file.chmod(0o755)


def run_dpkg_buildpackage(source_dir: Path) -> subprocess.CompletedProcess:
    """Execute dpkg-buildpackage to build package.

    Args:
        source_dir: Source directory to build from

    Returns:
        CompletedProcess result

    Raises:
        BuildError: If build fails
    """
    # Build command: binary only, unsigned
    cmd = ["dpkg-buildpackage", "-b", "-us", "-uc"]

    try:
        result = subprocess.run(
            cmd,
            cwd=source_dir,
            capture_output=True,
            text=True,
            check=False,
        )

        # Check if build was successful
        if result.returncode != 0:
            error_msg = f"dpkg-buildpackage failed with exit code {result.returncode}\n"
            error_msg += f"STDOUT:\n{result.stdout}\n"
            error_msg += f"STDERR:\n{result.stderr}"
            raise BuildError(error_msg)

        return result

    except FileNotFoundError as e:
        raise BuildError(
            "dpkg-buildpackage not found.\nInstall with: sudo apt install dpkg-dev debhelper"
        ) from e


def collect_artifacts(
    build_dir: Path, output_dir: Path, pkg_name: str, version: str
) -> list[Path]:
    """Collect build artifacts and move to output directory.

    Args:
        build_dir: Build directory containing artifacts
        output_dir: Destination directory for artifacts
        pkg_name: Package name
        version: Package version

    Returns:
        List of artifact paths in output directory
    """
    # Ensure output directory exists
    output_dir.mkdir(parents=True, exist_ok=True)

    # Patterns for artifacts in build_dir (not source_dir)
    patterns = [
        f"{pkg_name}_{version}_*.deb",
        f"{pkg_name}_{version}_*.buildinfo",
        f"{pkg_name}_{version}_*.changes",
    ]

    artifacts = []
    for pattern in patterns:
        matches = list(build_dir.glob(pattern))
        for artifact in matches:
            dest = output_dir / artifact.name
            shutil.move(str(artifact), str(dest))
            artifacts.append(dest)

    return artifacts


def inject_homarr_labels(
    compose: dict[str, Any], metadata: dict[str, Any], icon_path: Path | None = None
) -> dict[str, Any]:
    """Inject Homarr labels into docker-compose services.

    Args:
        compose: Original docker-compose dictionary
        metadata: Package metadata
        icon_path: Path to auto-detected icon file (optional)

    Returns:
        Modified docker-compose dictionary with Homarr labels added to services
    """
    # Generate labels from metadata
    homarr_labels = generate_homarr_labels(metadata, icon_path)

    # If no labels to add, return original compose
    if not homarr_labels:
        return compose

    # Deep copy to avoid modifying original
    import copy

    compose = copy.deepcopy(compose)

    # Get services section
    services = compose.get("services", {})

    # Add labels to each service
    for _service_name, service_config in services.items():
        if not isinstance(service_config, dict):
            continue

        # Get or create labels section
        existing_labels = service_config.get("labels", {})

        # Convert list format to dict if needed
        if isinstance(existing_labels, list):
            label_dict = {}
            for label in existing_labels:
                if "=" in label:
                    key, value = label.split("=", 1)
                    label_dict[key] = value
                else:
                    label_dict[label] = ""
            existing_labels = label_dict

        # Merge Homarr labels (don't overwrite existing)
        for key, value in homarr_labels.items():
            if key not in existing_labels:
                existing_labels[key] = value

        # Update service config
        service_config["labels"] = existing_labels

    return compose


def _fix_restart_policy(compose: dict[str, Any]) -> dict[str, Any]:
    """Fix boolean restart values that PyYAML parsed from YAML 1.1 'no'/'yes'.

    PyYAML interprets unquoted 'no', 'yes', 'on', 'off' as booleans per YAML 1.1.
    Docker Compose requires restart to be a string like "no", "always", etc.

    Args:
        compose: Docker compose dictionary

    Returns:
        Modified compose with restart booleans converted to strings
    """
    services = compose.get("services", {})
    for service_config in services.values():
        if not isinstance(service_config, dict):
            continue
        if "restart" in service_config:
            restart_val = service_config["restart"]
            if restart_val is False:
                service_config["restart"] = "no"
            elif restart_val is True:
                service_config["restart"] = "always"
    return compose


def generate_prestart_file(app_def: AppDefinition, source_dir: Path) -> None:
    """Generate or copy prestart.sh script file.

    If a custom prestart.sh exists in the app's input directory, it will be
    copied instead of generating the default script. This allows apps to
    implement custom initialization logic (e.g., generating secrets).

    Args:
        app_def: Application definition
        source_dir: Destination directory
    """
    prestart_file = source_dir / "prestart.sh"
    custom_prestart = app_def.input_dir / "prestart.sh"

    if custom_prestart.exists():
        # Use custom prestart script from app directory
        shutil.copy2(custom_prestart, prestart_file)
    else:
        # Generate default prestart script
        script_content = generate_prestart_script(app_def)
        prestart_file.write_text(script_content, encoding="utf-8")

    # Make executable
    prestart_file.chmod(0o755)


def generate_registry_file(app_def: AppDefinition, source_dir: Path) -> None:
    """Generate app registry TOML file for homarr-container-adapter.

    The registry file is used by homarr-container-adapter to discover and
    display apps on the Homarr dashboard. This replaces Docker-label-based
    discovery with static files.

    Args:
        app_def: Application definition
        source_dir: Destination directory

    The file is only generated if web_ui is enabled in metadata.
    """
    registry_content = generate_registry_toml(
        app_def.metadata, app_def.compose, app_def.icon_path
    )

    if registry_content is None:
        # web_ui not enabled, skip registry file generation
        return

    registry_file = source_dir / "webapp-registry.toml"
    registry_file.write_text(registry_content, encoding="utf-8")


def generate_oidc_snippet_file(app_def: AppDefinition, source_dir: Path) -> None:
    """Generate OIDC client snippet file for Authelia.

    The snippet file is installed to /etc/halos/oidc-clients.d/{app_id}.yml
    and merged by Authelia's prestart script to register the OIDC client.

    Args:
        app_def: Application definition
        source_dir: Destination directory

    The file is only generated if traefik.auth is 'oidc' in metadata.
    """
    snippet_content = generate_oidc_snippet(app_def.metadata)

    if snippet_content is None:
        # Not an OIDC app, skip snippet generation
        return

    oidc_snippet_file = source_dir / "oidc-client.yml"
    oidc_snippet_file.write_text(snippet_content, encoding="utf-8")


def generate_middleware_file(app_def: AppDefinition, source_dir: Path) -> None:
    """Generate per-app ForwardAuth middleware file for Traefik.

    The middleware file is installed to
    /var/lib/container-apps/traefik-container/dynamic/{app_id}.yml
    and loaded by Traefik's file provider.

    Args:
        app_def: Application definition
        source_dir: Destination directory

    The file is only generated if custom forward_auth headers are specified.
    """
    middleware_content = generate_forwardauth_middleware(app_def.metadata)

    if middleware_content is None:
        # No custom headers, skip middleware generation
        return

    middleware_file = source_dir / "traefik-middleware.yml"
    middleware_file.write_text(middleware_content, encoding="utf-8")


def generate_routing_file(app_def: AppDefinition, source_dir: Path) -> None:
    """Generate generic routing.yml file for reverse proxy.

    The routing file is installed to /etc/halos/routing.d/{app_id}.yml
    and read by the reverse proxy (e.g., Traefik) at runtime to generate
    native routing configuration.

    Args:
        app_def: Application definition
        source_dir: Destination directory

    The file is only generated if routing or traefik config is present,
    or if web_ui is enabled.
    """
    routing_content = generate_routing_yml(
        app_def.metadata, app_def.compose, app_def.metadata["package_name"]
    )

    if routing_content is None:
        # No routing needed, skip file generation
        return

    routing_file = source_dir / "routing.yml"
    routing_file.write_text(routing_content, encoding="utf-8")
