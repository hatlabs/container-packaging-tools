"""Generate generic routing.yml for proxy-agnostic routing configuration.

This module generates routing declarations that can be consumed by any
reverse proxy at runtime. The routing.yml file is installed to
/etc/halos/routing.d/{app_id}.yml and read by the reverse proxy's
prestart script to generate native configuration.
"""

from typing import Any

import yaml


def generate_routing_yml(
    metadata: dict[str, Any],
    compose: dict[str, Any],
    package_name: str,
) -> str | None:
    """Generate generic routing.yml content.

    Args:
        metadata: Package metadata dictionary
        compose: Docker compose dictionary
        package_name: Full package name (e.g., "marine-grafana-container")

    Returns:
        YAML string for /etc/halos/routing.d/{app_id}.yml, or None if no routing
        is configured.

    Raises:
        ValueError: If routing is configured but required information is missing.
    """
    app_id = metadata.get("app_id", "")

    # Get routing config from either 'routing' or 'traefik' key
    routing_config = metadata.get("routing")
    traefik_config = metadata.get("traefik")
    web_ui = metadata.get("web_ui", {})

    # Determine if we need routing
    has_routing = routing_config is not None
    has_traefik = traefik_config is not None
    has_web_ui = web_ui.get("enabled", False) if web_ui else False

    # No routing needed if no config and no web UI
    if not has_routing and not has_traefik and not has_web_ui:
        return None

    # Detect host networking from compose
    is_host_network = _detect_host_networking(compose)

    # Get first service name
    services = compose.get("services", {})
    if not services:
        raise ValueError("No services found in docker-compose.yml")
    first_service = next(iter(services.keys()))

    # Determine port
    port = _get_port(routing_config, traefik_config, web_ui, is_host_network)

    # Determine subdomain
    subdomain = _get_subdomain(routing_config, traefik_config, app_id)

    # Determine auth mode and config
    auth_mode, forward_auth_headers = _get_auth_config(routing_config, traefik_config)

    # Build the routing structure
    routing_data: dict[str, Any] = {
        "app_id": app_id,
        "package_name": package_name,
        "routing": {
            "subdomain": subdomain,
            "backend": {
                "type": "host" if is_host_network else "container",
                "service": first_service,
                "port": port,
            },
            "entry_points": ["http", "https"],
        },
        "auth": {
            "mode": auth_mode,
        },
        "network": {
            "join_proxy_network": not is_host_network,
        },
    }

    # Add forward_auth headers if present
    if forward_auth_headers:
        routing_data["auth"]["forward_auth"] = {"headers": forward_auth_headers}

    # Generate YAML with header comment
    header = f"""# Generic routing declaration for {app_id}
# Installed to /etc/halos/routing.d/{app_id}.yml
# Generated by container-packaging-tools
#
# This file is read by the reverse proxy at runtime to generate
# native routing configuration (e.g., Traefik labels).

"""
    return header + yaml.dump(routing_data, default_flow_style=False, sort_keys=False)


def _detect_host_networking(compose: dict[str, Any]) -> bool:
    """Detect if any service uses host networking."""
    services = compose.get("services", {})
    for service_config in services.values():
        if service_config.get("network_mode") == "host":
            return True
    return False


def _get_port(
    routing_config: dict | None,
    traefik_config: dict | None,
    web_ui: dict | None,
    is_host_network: bool,
) -> int:
    """Get the port for routing.

    Priority:
    1. routing.host_port or traefik.host_port (for host networking)
    2. web_ui.port
    """
    # Check for explicit host_port in routing or traefik config
    host_port = None
    if routing_config:
        host_port = routing_config.get("host_port")
    if host_port is None and traefik_config:
        host_port = traefik_config.get("host_port")

    # For host networking, prefer host_port, fall back to web_ui.port
    if is_host_network:
        if host_port is not None:
            return host_port
        if web_ui and web_ui.get("port"):
            return web_ui["port"]
        raise ValueError(
            "Host networking requires either host_port in routing config "
            "or port in web_ui config"
        )

    # For container networking, use web_ui.port
    if web_ui and web_ui.get("port"):
        return web_ui["port"]

    raise ValueError("Port is required: set web_ui.port in metadata.yaml")


def _get_subdomain(
    routing_config: dict | None,
    traefik_config: dict | None,
    app_id: str,
) -> str:
    """Get the subdomain for routing.

    Priority:
    1. routing.subdomain
    2. traefik.subdomain
    3. app_id (default)
    """
    if routing_config and "subdomain" in routing_config:
        subdomain = routing_config["subdomain"]
        # Could be None (not specified) or "" (empty string for root)
        if subdomain is not None:
            return subdomain

    if traefik_config and "subdomain" in traefik_config:
        subdomain = traefik_config["subdomain"]
        if subdomain is not None:
            return subdomain

    # Default to app_id
    return app_id


def _get_auth_config(
    routing_config: dict | None,
    traefik_config: dict | None,
) -> tuple[str, dict[str, str] | None]:
    """Get the auth mode and forward_auth headers.

    Supports multiple formats:
    1. Nested format: routing.auth = {mode: "...", forward_auth: {...}}
    2. Flat format (like traefik): routing.auth = "...", routing.forward_auth = {...}
    3. Legacy traefik format: traefik.auth = "...", traefik.forward_auth = {...}

    Returns:
        Tuple of (auth_mode, forward_auth_headers or None)
    """
    auth_mode = "forward_auth"  # Default
    forward_auth_headers: dict[str, str] | None = None

    # Check routing config first
    if routing_config:
        auth_config = routing_config.get("auth")
        if auth_config:
            if isinstance(auth_config, dict):
                # Nested format: auth: {mode: "forward_auth", forward_auth: {...}}
                auth_mode = auth_config.get("mode", "forward_auth")
                fa_config = auth_config.get("forward_auth")
                if fa_config and fa_config.get("headers"):
                    forward_auth_headers = fa_config["headers"]
            elif isinstance(auth_config, str):
                # Flat format: auth: "forward_auth"
                auth_mode = auth_config
                # Check for forward_auth at routing level (flat format)
                fa_config = routing_config.get("forward_auth")
                if fa_config and fa_config.get("headers"):
                    forward_auth_headers = fa_config["headers"]
        else:
            # No auth config, but check for forward_auth at routing level
            fa_config = routing_config.get("forward_auth")
            if fa_config and fa_config.get("headers"):
                forward_auth_headers = fa_config["headers"]

    # Fall back to traefik config (legacy format)
    elif traefik_config:
        auth_mode = traefik_config.get("auth", "forward_auth")
        fa_config = traefik_config.get("forward_auth")
        if fa_config and fa_config.get("headers"):
            forward_auth_headers = fa_config["headers"]

    return auth_mode, forward_auth_headers
