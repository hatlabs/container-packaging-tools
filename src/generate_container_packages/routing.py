"""Generate generic routing.yml for proxy-agnostic routing configuration.

This module generates routing declarations that can be consumed by any
reverse proxy at runtime. The routing.yml file is installed to
/etc/halos/routing.d/{app_id}.yml and read by the reverse proxy's
prestart script to generate native configuration.
"""

from typing import Any

import yaml


def generate_routing_yml(
    metadata: dict[str, Any],
    compose: dict[str, Any],
    package_name: str,
) -> str | None:
    """Generate generic routing.yml content.

    Args:
        metadata: Package metadata dictionary
        compose: Docker compose dictionary
        package_name: Full package name (e.g., "marine-grafana-container")

    Returns:
        YAML string for /etc/halos/routing.d/{app_id}.yml, or None if no routing
        is configured.

    Raises:
        ValueError: If routing is configured but required information is missing.
    """
    app_id = metadata.get("app_id", "")

    # Get routing config
    routing_config = metadata.get("routing")
    web_ui = metadata.get("web_ui", {})

    # Determine if we need routing
    has_routing = routing_config is not None
    has_web_ui = web_ui.get("enabled", False) if web_ui else False

    # No routing needed if no config and no web UI
    if not has_routing and not has_web_ui:
        return None

    # Detect host networking from compose
    is_host_network = _detect_host_networking(compose)

    # Get first service name
    services = compose.get("services", {})
    if not services:
        raise ValueError("No services found in docker-compose.yml")
    first_service = next(iter(services.keys()))

    # Determine port
    port = _get_port(routing_config, web_ui, is_host_network, compose)

    # Determine subdomain
    subdomain = _get_subdomain(routing_config, app_id)

    # Determine auth mode and config
    auth_mode, forward_auth_headers = _get_auth_config(routing_config)

    # Build the routing structure
    routing_data: dict[str, Any] = {
        "app_id": app_id,
        "package_name": package_name,
        "routing": {
            "subdomain": subdomain,
            "backend": {
                "type": "host" if is_host_network else "container",
                "service": first_service,
                "port": port,
            },
            "entry_points": ["http", "https"],
        },
        "auth": {
            "mode": auth_mode,
        },
        "network": {
            "join_proxy_network": not is_host_network,
        },
    }

    # Add forward_auth headers if present
    if forward_auth_headers:
        routing_data["auth"]["forward_auth"] = {"headers": forward_auth_headers}

    # Generate YAML with header comment
    header = f"""# Generic routing declaration for {app_id}
# Installed to /etc/halos/routing.d/{app_id}.yml
# Generated by container-packaging-tools
#
# This file is read by the reverse proxy at runtime to generate
# native routing configuration (e.g., Traefik labels).

"""
    return header + yaml.dump(routing_data, default_flow_style=False, sort_keys=False)


def _detect_host_networking(compose: dict[str, Any]) -> bool:
    """Detect if any service uses host networking."""
    services = compose.get("services", {})
    for service_config in services.values():
        if service_config.get("network_mode") == "host":
            return True
    return False


def _extract_container_port(compose: dict[str, Any]) -> int | None:
    """Extract the container port from the first port mapping.

    Docker-compose ports can be in formats like:
    - "8080" (just container port)
    - "3011:8080" (host:container)
    - "${PORT:-3011}:8080" (env var host:container)
    - "3011:8080/tcp" (with protocol)

    Args:
        compose: Parsed docker-compose.yml

    Returns:
        Container port as integer, or None if no ports defined
    """
    services = compose.get("services", {})
    for service_config in services.values():
        if not isinstance(service_config, dict):
            continue

        ports = service_config.get("ports", [])
        if not ports:
            continue

        # Get first port mapping
        port_mapping = ports[0]

        # Handle dict format (long syntax)
        if isinstance(port_mapping, dict):
            target = port_mapping.get("target")
            if target is not None:
                return int(target)
            continue

        # Handle string format (short syntax)
        if isinstance(port_mapping, str):
            # Remove protocol suffix if present (e.g., "/tcp", "/udp")
            port_str = port_mapping.split("/")[0]

            # Check for host:container format
            if ":" in port_str:
                # Take the right side (container port)
                container_port = port_str.rsplit(":", 1)[1]
                return int(container_port)
            else:
                # Just container port
                return int(port_str)

        # Handle integer format
        if isinstance(port_mapping, int):
            return port_mapping

    return None


def _get_port(
    routing_config: dict | None,
    web_ui: dict | None,
    is_host_network: bool,
    compose: dict[str, Any],
) -> int:
    """Get the port for routing.

    Priority for host networking:
    1. routing.host_port
    2. web_ui.port

    Priority for container networking:
    1. Container port from docker-compose port mapping
    2. web_ui.port (fallback)
    """
    # Check for explicit host_port in routing config
    host_port = None
    if routing_config:
        host_port = routing_config.get("host_port")

    # For host networking, prefer host_port, fall back to web_ui.port
    if is_host_network:
        if host_port is not None:
            return host_port
        if web_ui and web_ui.get("port"):
            return web_ui["port"]
        raise ValueError(
            "Host networking requires either host_port in routing config "
            "or port in web_ui config"
        )

    # For container networking, prefer container port from docker-compose
    container_port = _extract_container_port(compose)
    if container_port is not None:
        return container_port

    # Fall back to web_ui.port
    if web_ui and web_ui.get("port"):
        return web_ui["port"]

    raise ValueError(
        "Port is required: set web_ui.port in metadata.yaml or define ports in docker-compose.yml"
    )


def _get_subdomain(
    routing_config: dict | None,
    app_id: str,
) -> str:
    """Get the subdomain for routing.

    Priority:
    1. routing.subdomain
    2. app_id (default)
    """
    if routing_config and "subdomain" in routing_config:
        subdomain = routing_config["subdomain"]
        # Could be None (not specified) or "" (empty string for root)
        if subdomain is not None:
            return subdomain

    # Default to app_id
    return app_id


def _get_auth_config(
    routing_config: dict | None,
) -> tuple[str, dict[str, str] | None]:
    """Get the auth mode and forward_auth headers.

    Supports multiple formats:
    1. Nested format: routing.auth = {mode: "...", forward_auth: {...}}
    2. Flat format: routing.auth = "...", routing.forward_auth = {...}

    Returns:
        Tuple of (auth_mode, forward_auth_headers or None)
    """
    auth_mode = "forward_auth"  # Default
    forward_auth_headers: dict[str, str] | None = None

    if routing_config:
        auth_config = routing_config.get("auth")
        if auth_config:
            if isinstance(auth_config, dict):
                # Nested format: auth: {mode: "forward_auth", forward_auth: {...}}
                auth_mode = auth_config.get("mode", "forward_auth")
                fa_config = auth_config.get("forward_auth")
                if fa_config and fa_config.get("headers"):
                    forward_auth_headers = fa_config["headers"]
            elif isinstance(auth_config, str):
                # Flat format: auth: "forward_auth"
                auth_mode = auth_config
                # Check for forward_auth at routing level (flat format)
                fa_config = routing_config.get("forward_auth")
                if fa_config and fa_config.get("headers"):
                    forward_auth_headers = fa_config["headers"]
        else:
            # No auth config, but check for forward_auth at routing level
            fa_config = routing_config.get("forward_auth")
            if fa_config and fa_config.get("headers"):
                forward_auth_headers = fa_config["headers"]

    return auth_mode, forward_auth_headers
